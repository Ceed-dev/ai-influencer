// AUTO-GENERATED from 04-agent-design.md — DO NOT EDIT MANUALLY

// ============================================================================
// LangGraph State Types — 4 Graphs
// ============================================================================
// Graph 1: StrategyCycleState      — Daily strategy cycle orchestration
// Graph 2: ProductionPipelineState — Video/text content production
// Graph 3: PublishingSchedulerState — Multi-platform posting workflow
// Graph 4: MeasurementJobState     — Post-publication metrics collection
// ============================================================================

// ---------------------------------------------------------------------------
// Shared enums & base types
// ---------------------------------------------------------------------------

/** Agent roles participating in strategy cycle */
export type AgentType =
  | 'strategist'
  | 'researcher'
  | 'analyst'
  | 'tool_specialist'
  | 'data_curator'
  | 'planner';

/** Supported content formats — determines worker dispatch */
export type ContentFormat = 'short_video' | 'text_post' | 'image_post';

/** Script language — selects script_en or script_jp from scenarios */
export type ScriptLanguage = 'en' | 'jp';

/** Supported social platforms */
export type Platform = 'youtube' | 'tiktok' | 'instagram' | 'x';

/** Approval status used by both AI and human approval steps */
export type ApprovalStatus = 'approved' | 'rejected';

/** Rejection category — determines routing target on rejection */
export type RejectionCategory =
  | 'plan_revision'       // → plan_content node (default)
  | 'data_insufficient'   // → collect_intel node
  | 'hypothesis_weak';    // → analyze_cycle node

/** Measurement collection window */
export type MeasurementType = '48h' | '7d' | '30d';

// ---------------------------------------------------------------------------
// Graph 1: Strategy Cycle Graph — 戦略サイクルグラフ
// ---------------------------------------------------------------------------
// Frequency: Daily (cron, once per morning)
// Agents: Strategist (Opus) + Researcher (Sonnet) + Analyst (Sonnet)
//         + Planner (Sonnet x N) + Tool Specialist (Sonnet)
// Purpose: market intel → hypothesis → content plans → approval cycle
// ---------------------------------------------------------------------------

/** Node names for the strategy cycle graph */
export type StrategyCycleNode =
  | 'collect_intel'
  | 'analyze_cycle'
  | 'set_strategy'
  | 'plan_content'
  | 'select_tools'
  | 'approve_plan'
  | 'human_approval'
  | 'reflect_all';

/** Trending topic from market intelligence */
export interface TrendingTopic {
  topic: string;
  platform: Platform;
  relevance_score: number; // 0.00–1.00
  source: string;
  detected_at: string; // ISO 8601
}

/** Competitor insight from research */
export interface CompetitorInsight {
  competitor_name: string;
  platform: Platform;
  observation: string;
  engagement_metrics?: Record<string, number>;
}

/** Platform update (algorithm changes, new features, etc.) */
export interface PlatformUpdate {
  platform: Platform;
  update_type: string;
  description: string;
  impact_assessment: string;
  detected_at: string; // ISO 8601
}

/** Audience signal from analytics */
export interface AudienceSignal {
  signal_type: string;
  description: string;
  confidence: number; // 0.00–1.00
  affected_niches: string[];
}

/** Previous cycle review summary */
export interface CycleReview {
  cycle_id: number;
  overall_score: number; // 1–10
  key_findings: string[];
  recommendations: string[];
}

/** Hypothesis verification result from analyst */
export interface HypothesisVerification {
  hypothesis_id: number;
  verdict: 'validated' | 'invalidated' | 'inconclusive';
  actual_kpis: Record<string, number>;
  predicted_kpis: Record<string, number>;
  deviation_pct: number;
  explanation: string;
}

/** Anomaly detected in metrics */
export interface Anomaly {
  metric_name: string;
  account_id: string;
  expected_value: number;
  actual_value: number;
  sigma_deviation: number;
  severity: 'low' | 'medium' | 'high';
  description: string;
}

/** Learning extracted from analysis */
export interface Learning {
  learning_id?: number;
  category: string;
  insight: string;
  confidence: number; // 0.00–1.00
  applicable_niches: string[];
  source_hypothesis_id?: number;
}

/** Resource allocation per cluster */
export interface ResourceAllocation {
  cluster: string;
  content_count: number;
  budget_usd: number;
}

/** Content plan generated by planner */
export interface ContentPlan {
  content_id: string;
  hypothesis_id: number;
  character_id: string;
  content_format: ContentFormat;
  script_language: ScriptLanguage;
  planned_post_date: string; // YYYY-MM-DD
  sections: ContentPlanSection[];
}

/** Section within a content plan */
export interface ContentPlanSection {
  section_order: number;
  section_label: string; // e.g. "hook", "body", "cta"
  component_id: string;
  script?: string;
}

/** Tool recipe designed by tool specialist */
export interface ToolRecipe {
  content_id: string;
  video_gen: string;   // 'kling' | 'runway' | 'pika' | 'sora'
  tts: string;         // 'fish_audio' | 'elevenlabs'
  lipsync: string;     // 'sync_lipsync' | 'hedra'
  concat: string;      // 'ffmpeg' (currently fixed)
  rationale: string;   // Tool specialist's selection reasoning
  parameters?: Record<string, unknown>; // Tool-specific parameter recommendations
}

/** Agent self-reflection result (reflect_all node output) */
export interface AgentReflection {
  agent_type: AgentType;
  self_score: number; // 1–10
  score_reasoning: string;
  what_went_well: string[];
  what_to_improve: string[];
  next_actions: string[];
}

/** Agent error record */
export interface AgentError {
  node: StrategyCycleNode;
  agent_type: AgentType;
  error_message: string;
  error_code?: string;
  occurred_at: string; // ISO 8601
  recovery_action?: string;
  is_recoverable: boolean;
}

/** Approval result (used by both approve_plan and human_approval) */
export interface ApprovalResult {
  status: ApprovalStatus;
  feedback?: string;
  rejection_category?: RejectionCategory;
  revision_count: number; // max 3 — forced approval beyond this
}

/** Human approval result from dashboard interrupt */
export interface HumanApprovalResult {
  status: ApprovalStatus;
  feedback?: string; // Feedback on rejection
  rejection_category?: RejectionCategory;
}

/** System config flags embedded in state */
export interface StrategyCycleConfig {
  /** Whether human approval step is enabled (system_settings, default: true) */
  HUMAN_REVIEW_ENABLED: boolean;
}

/** Full state for Strategy Cycle Graph (Graph 1) */
export interface StrategyCycleState {
  // -- Cycle info --
  cycle_id: number;
  cycle_number: number;
  started_at: string; // ISO 8601

  // -- Market data (collect_intel node output) --
  market_intel: {
    trending_topics: TrendingTopic[];
    competitor_insights: CompetitorInsight[];
    platform_updates: PlatformUpdate[];
    audience_signals: AudienceSignal[];
  };

  // -- Analysis results (analyze_cycle node output) --
  analysis: {
    previous_cycle_review: CycleReview | null;
    hypothesis_verifications: HypothesisVerification[];
    anomalies: Anomaly[];
    new_learnings: Learning[];
    algorithm_accuracy: number; // 0.00–1.00
  };

  // -- Strategic direction (set_strategy node output) --
  strategy: {
    focus_niches: string[];
    resource_allocation: ResourceAllocation[];
    human_directives_processed: number[]; // IDs of processed directives
    key_decisions: string[];
  };

  // -- Content plans (plan_content node output) --
  content_plans: ContentPlan[];

  // -- Tool recipes (select_tools node output) --
  tool_recipes: ToolRecipe[];

  // -- AI approval (approve_plan node output) --
  approval: ApprovalResult;

  // -- Human approval (human_approval node output) --
  human_approval: HumanApprovalResult;

  // -- System config --
  config: StrategyCycleConfig;

  // -- Self-reflections (reflect_all node output) --
  reflections: AgentReflection[];

  // -- Errors --
  errors: AgentError[];
}

/** Edge condition: approve_plan → next node routing */
export type ApprovePlanEdgeResult =
  | 'human_approval'
  | 'reflect_all'
  | 'collect_intel'
  | 'analyze_cycle'
  | 'plan_content';

/** Edge condition: human_approval → next node routing */
export type HumanApprovalEdgeResult =
  | 'reflect_all'
  | 'collect_intel'
  | 'analyze_cycle'
  | 'plan_content';

/** Checkpoint metadata for strategy cycle */
export interface StrategyCycleCheckpoint {
  thread_id: string;
  cycle_id: number;
  last_completed_node: StrategyCycleNode;
  completed_at: string; // ISO 8601
  revision_count: number;
}

// ---------------------------------------------------------------------------
// Graph 2: Production Pipeline Graph — 制作パイプライングラフ
// ---------------------------------------------------------------------------
// Frequency: Continuous (30s polling, PM2 daemon)
// Agents: Video production worker (code, no LLM) + Text production worker (LLM)
// Purpose: Detect 'planned' content → dispatch to appropriate worker → quality check
// ---------------------------------------------------------------------------

/** Node names for the production pipeline graph */
export type ProductionPipelineNode =
  | 'poll_tasks'
  | 'sleep'
  | 'fetch_data'
  | 'dispatch'
  | 'generate_video'
  | 'generate_text'
  | 'quality_check'
  | 'handle_error'
  | 'revision_planning';

/** Component data attached to a production section */
export interface ComponentData {
  component_id: string;
  component_type: string;
  content: Record<string, unknown>;
  drive_file_id?: string;
}

/** Video section production result */
export interface SectionResult {
  request_id: string;          // Video generation API request ID
  video_url: string;
  tts_audio_url: string;
  lipsync_video_url: string;
  processing_seconds: number;
}

/** Production error record */
export interface ProductionError {
  node: ProductionPipelineNode;
  error_message: string;
  error_code?: string;
  occurred_at: string; // ISO 8601
  retry_count: number;
  is_retryable: boolean;
}

/** Production task info */
export interface ProductionTask {
  task_id: number;
  content_id: string;
  content_format: ContentFormat;
  account_id: string;
  character_id: string;
  script_language: ScriptLanguage;
  recipe_id: number | null; // null for text_post
  sections: ProductionSection[];
}

/** Section within a production task */
export interface ProductionSection {
  section_order: number;
  section_label: string; // Dynamic: "hook", "body", "cta", "intro", "summary", etc.
  component: ComponentData;
}

/** Character info loaded during fetch_data */
export interface ProductionCharacter {
  name: string;
  voice_id: string;       // Fish Audio 32-char hex
  image_drive_id: string; // Google Drive file ID
  image_fal_url?: string; // fal.storage URL after upload
}

/** Production status tracking */
export type ProductionStatus =
  | 'idle'
  | 'fetching'
  | 'dispatching'
  | 'generating'
  | 'quality_check'
  | 'error';

/** Production progress state */
export interface ProductionProgress {
  status: ProductionStatus;
  /** Section results keyed by section_label (dynamic, defined by content_sections table) */
  sections: Record<string, SectionResult | null>;
  generated_text?: string;         // text_post: generated text content
  final_video_url?: string;        // short_video: final concatenated video URL
  drive_folder_id?: string;
  video_drive_id?: string;
  processing_time_seconds?: number;
}

/** Review status for quality-checked content */
export type ReviewStatus =
  | 'pending_review'
  | 'auto_approved'
  | 'approved'
  | 'rejected'
  | 'revision_planned';

/** Full state for Production Pipeline Graph (Graph 2) */
export interface ProductionPipelineState {
  // -- Current task --
  current_task: ProductionTask | null;

  // -- Character info --
  character: ProductionCharacter | null;

  // -- Production progress --
  production: ProductionProgress;

  // -- Review (quality_check + human/auto review) --
  review: {
    status: ReviewStatus;
    quality_score?: number;        // 0.0–10.0
    reviewer_feedback?: string;    // Human reviewer comment on rejection
    revision_count: number;        // Max: MAX_CONTENT_REVISION_COUNT (default: 3)
    auto_approve_threshold: number; // AUTO_APPROVE_SCORE_THRESHOLD (default: 8.0)
  };

  // -- System config --
  config: {
    /** Human review required for all content (system_settings, default: true) */
    HUMAN_REVIEW_ENABLED: boolean;
    /** Quality score threshold for auto-approval (system_settings, default: 8.0) */
    AUTO_APPROVE_SCORE_THRESHOLD: number;
    /** Max revision attempts before cancellation (system_settings, default: 3) */
    MAX_CONTENT_REVISION_COUNT: number;
  };

  // -- Errors --
  errors: ProductionError[];
}

/** Edge condition: dispatch → worker selection */
export type DispatchEdgeResult =
  | 'generate_video'
  | 'generate_text';
// 'generate_image' — future extension for image_post

/** Edge condition: quality_check / handle_error → next step */
export type PostProductionEdgeResult =
  | 'poll_tasks'     // Success or unrecoverable error → back to polling
  | 'handle_error';  // Quality check failed

/** Checkpoint metadata for production pipeline */
export interface ProductionPipelineCheckpoint {
  thread_id: string;
  content_id: string;
  last_completed_node: ProductionPipelineNode;
  completed_at: string; // ISO 8601
  completed_sections: string[]; // section_labels that finished successfully
}

// ---------------------------------------------------------------------------
// Graph 3: Publishing Scheduler Graph — 投稿スケジューラーグラフ
// ---------------------------------------------------------------------------
// Frequency: Continuous (POSTING_POLL_INTERVAL_SEC, default: 120s polling)
// Agents: Publishing worker (code)
// Purpose: Post 'ready' content at optimal times respecting rate limits
// ---------------------------------------------------------------------------

/** Node names for the publishing scheduler graph */
export type PublishingSchedulerNode =
  | 'check_schedule'
  | 'sleep'
  | 'publish'
  | 'record'
  | 'handle_error';

/** Publishing metadata per platform */
export interface PublishMetadata {
  title?: string;             // YouTube
  description?: string;       // YouTube, TikTok
  caption?: string;           // Instagram
  text?: string;              // X
  tags?: string[];
  thumbnail_drive_id?: string;
}

/** Current publishing task */
export interface PublishTask {
  task_id: number;
  content_id: string;
  account_id: string;
  platform: Platform;
  video_drive_id: string;
  metadata: PublishMetadata;
}

/** Publish result after posting attempt */
export interface PublishResult {
  status: 'success' | 'failed';
  platform_post_id?: string;
  post_url?: string;
  posted_at?: string;        // ISO 8601
  measure_after?: string;    // posted_at + 48h (ISO 8601)
  error?: string;
}

/** Per-platform rate limit tracking */
export interface PlatformRateLimit {
  remaining: number;
  reset_at: string; // ISO 8601
}

/** Full state for Publishing Scheduler Graph (Graph 3) */
export interface PublishingSchedulerState {
  // -- Current task --
  current_task: PublishTask | null;

  // -- Publish result --
  publish_result: PublishResult | null;

  // -- Rate limit tracking (keyed by platform) --
  rate_limits: Record<Platform, PlatformRateLimit>;
}

/** Edge condition: publish → result handling */
export type PublishEdgeResult =
  | 'record'        // Success → record result
  | 'handle_error'; // Failure → error handling

/** Checkpoint metadata for publishing scheduler */
export interface PublishingSchedulerCheckpoint {
  thread_id: string;
  content_id: string;
  last_completed_node: PublishingSchedulerNode;
  completed_at: string; // ISO 8601
  platform: Platform;
}

// ---------------------------------------------------------------------------
// Graph 4: Measurement Jobs Graph — 計測ジョブグラフ
// ---------------------------------------------------------------------------
// Frequency: Continuous (MEASUREMENT_POLL_INTERVAL_SEC, default: 300s polling)
// Agents: Measurement worker (code)
// Purpose: Collect metrics for content posted ≥ 48h ago
// ---------------------------------------------------------------------------

/** Node names for the measurement jobs graph */
export type MeasurementJobNode =
  | 'detect_targets'
  | 'sleep'
  | 'collect'
  | 'save_metrics';

/** Measurement target — a publication awaiting metrics collection */
export interface MeasurementTarget {
  task_id: number;
  publication_id: number;
  content_id: string;
  account_id: string;
  platform: Platform;
  platform_post_id: string;
  posted_at: string;          // ISO 8601
  measurement_type: MeasurementType;
}

/** Collected metrics from platform API */
export interface CollectedMetrics {
  views: number;
  likes: number;
  comments: number;
  shares: number;
  saves?: number;
  watch_time_seconds?: number;
  completion_rate?: number;    // 0.00–1.00
  engagement_rate: number;     // Calculated: (likes + comments + shares) / views
  follower_delta: number;
  impressions?: number;
  reach?: number;
  raw_data: Record<string, unknown>; // Full API response for archival
}

/** Full state for Measurement Jobs Graph (Graph 4) */
export interface MeasurementJobState {
  // -- Measurement targets batch --
  targets: MeasurementTarget[];

  // -- Currently processing --
  current_target: MeasurementTarget | null;

  // -- Collection result --
  collected_metrics: CollectedMetrics | null;

  // -- Batch progress counters --
  processed_count: number;
  error_count: number;
}

/** Edge condition: detect_targets → collect or sleep */
export type DetectTargetsEdgeResult =
  | 'collect'   // Targets found → start collection
  | 'sleep';    // No targets → wait 5 min

/** Checkpoint metadata for measurement jobs */
export interface MeasurementJobCheckpoint {
  thread_id: string;
  last_completed_node: MeasurementJobNode;
  completed_at: string; // ISO 8601
  batch_processed: number;
  batch_errors: number;
}

// ---------------------------------------------------------------------------
// Cross-graph coordination types
// ---------------------------------------------------------------------------
// All 4 graphs communicate ONLY through PostgreSQL (content.status + task_queue).
// No direct graph-to-graph communication.
// ---------------------------------------------------------------------------

/** Content status flow across graphs */
export type ContentStatus =
  | 'pending_approval'  // Strategy cycle → awaiting human approval
  | 'planned'           // Approved → ready for production pipeline
  | 'producing'         // Production pipeline picked up the task
  | 'ready'             // Production complete → ready for publishing
  | 'posted'            // Published → awaiting measurement
  | 'measured'          // Initial metrics collected
  | 'analyzed'          // All publications measured, analysis complete
  | 'error'             // Terminal: unrecoverable error
  | 'cancelled';        // Terminal: cancelled by human or system

/** Publication status flow */
export type PublicationStatus =
  | 'scheduled'   // Created by strategy cycle
  | 'posted'      // Published by publishing scheduler
  | 'measured';   // Metrics collected by measurement jobs

/** Task queue entry types bridging graphs */
export type TaskQueueType =
  | 'produce'    // Strategy → Production
  | 'publish'    // Production → Publishing
  | 'measure'    // Publishing → Measurement
  | 'curate';    // Planner → Data Curator
